## ძირითადი პრობლემა:
თუ რამდენიმე ნაკადი ერთდროულად ცდილობს ერთი და იგივე მონაცემზე (ამ შემთხვევაში, _counter ცვლადზე) წვდომას და ცვლილებას, 
შეიძლება წარმოიშვას ე.წ. Race Condition, როდესაც რამდენიმე thread ერთდროულად ცვლის მონაცემს, რაც საბოლოოდ არასწორ შედეგზე გაგვიყვანს.

მაგალითად, 10 ნაკადი ერთდროულად რომ ცდილობდეს _counter-ის გაზრდას 1-ით, არსებობს რისკი, რომ ნაკადები ერთმანეთს "გადაასწრებენ" და ზოგიერთი ოპერაცია არ შესრულდება სწორად, რაც გამოიწვევს საბოლოო ასევე არაკორექტულ შედეგს.

## როგორ წყვეტს კოდი პრობლემას:
lock უზრუნველყოფს, რომ ერთდროულად მხოლოდ ერთი ნაკადს შეეძლოს _counter-ზე წვდომა და ცვლილება. თუ ერთი ნაკადი lock-შია, სხვა ნაკადები ელოდებიან, სანამ ის გაათავისუფლებს ლოკს.
ამით ნაკადები მორიგეობით და თანმიმდევრულად გაზრდიან _counter-ს და არ წარმოიქმნება Race Condition. რაც შეეხება Sleep მეთოდის გამოყენებას, ნაკადის მუშაობის სიმულაციისთვის ჩავამატე (10 მილიწამი დაელოდოს შემდეგ ნაბიჯამდე).


##  შეჯამება:
ShowBadExample მეთოდი გვაჩვენებს იმ ცუდ ქეისს როდესაც დგება Race Condition და არასწორად ხდება ჩვენი counter ცვლადის ინკემენტირება.
ShowGoodExample მეთოდში კი უზრუნველყოფილია ნაკადების სინქრონიზაცია და საზიარო რესურსის (shared resource) დაცვა lock მექანიზმის მეშვეობით, რის შემდეგაც ნაკადები უერთდება primary ნაკადს.

##### Interlocked.Increment(ref int location) არის ასევე საინტერესო მეთოდი, რომელიც ატომურად ასრულებს ოპერაციას